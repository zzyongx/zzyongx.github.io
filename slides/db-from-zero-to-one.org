#+Title: 数据库系统的构建、使用、优化
#+Author: 郑志勇
#+Email: zhengzhiyong@sogou-inc.com

* 基础知识
- 数组
- 对象
- JSON
- 算法时间复杂度

* 算法时间复杂度
- O(1)      array[n], 哈希
- O(N)      全表扫描
- O(logN)   B树索引
- O(N*logN) 归并排序 
- O(N*N)    集合的交、并

* 数据库背景下的复杂度
- 磁盘IO非常昂贵
- 是否顺序读取
- IO次数和IO块儿次数
- 可用内存

* 数据库的基本要素
- 数据
- 操作

* 数据
- 量
- 业务的数据特点
- 数据的操作特定
- 优化都是基于（业务）查询和数据的分布的

* 数据的操作
- 读
- 增
- 改（可选）
- 删（可选）

* 如何构建一个员工数据库
- 数据量小
- 操作少

* 公司的员工库
|ID|Name|Birthday |Gender |
|1011|王小明|7月1日|男|
|1012|张壮壮|3月2日|男|
|1032|张静|4月5日|女|
|1033|王丫|9月10日|女|

* 表和JSON
[{"ID": 1011, "Name": "王小明", "Birthday": "7月1日",  "Gender": "男"},

 {"ID": 1012, "Name": "张壮壮", "Birthday": "3月2日",  "Gender": "男"},

 {"ID": 1032, "Name": "张静",   "Birthday": "4月5日",  "Gender": "女"},

 {"ID": 1033, "Name": "王丫",   "Birthday": "9月10日", "Gender": "女"}]

* 文本数据库(V1)
 - 接请求，加锁，读文件
 - 反序列化，JSON
 - 增删改查
 - JSON，序列化
 - 写文件，释放锁，返回请求
 - 如有必要，返回前，同步文件到备机

* 简单，却功能完备
- 完整性
- 持久性
- 高可用

* 文本数据库的问题
- O(N) 的操作性能
- 磁盘IO浪费
- JSON浪费磁盘和CPU
- 互斥锁

* 内存数据库(V2)
- (启动阶段) 加载数据，构建索引
- 接请求，读写锁
- 增删改查
- 如果有修改，写入增量文件
- 释放锁，返回请求
- 如有必要，返回前，同步增量到备机

* V1到V2的启示
- 缓存是最伟大的优化
- 缓存一致性是复杂的根源
- 预计算
- 空间换时间
- 依赖内存，功能变弱

* 数据的组成
- 数据文件，定期dump
- 增量文件，顺序IO
- 增量文件和数据文件合起来是全部数据
- 所有的数据放入内存（数组形式）

* 读写锁
- 并发读
- 独占写
- 粒度是库

* O(N) 的根源
- 数据的组织形式
- 数组的很多操作是O(N)的
- 基于数组的优化
- 基于额外索引的优化

* 数组特点图

* 数组的特点
- 位置宣示关系
- 关系表示很廉价，无序额外指针
- 维护关系可能很昂贵

* 基于数组的优化
- 有序
- 增 删 改 O(N)
- 二分查找 O(logN)
- 已知下标 O(1)

* 继续数组的优化
- 大小数组
- 大数组假删
- 增，改在小数组
- 定期合并，排序O(N*logN)
- 加锁粒度的变化

* 根据谁排序
- ID，Name，Birthday，Gender ？
- 查询决定优化
- 如果有多种查询，咋办
- 数组不能同时满足两种有序

* 数组的启示
- 
- 有序是关键
- 排序的是指针
- 

* 哈希的特点
- 无序
- 增删改查 O(1)
- 用于Hash的Key必须是确定的
- 额外的指针

* B+树
- Key不必完整
- 有序
- 增删改查 O(logN)
- 额外的指针

* 位图索引
- Key的个数优先
- 索引非常小

* 索引是什么
- 根据Key找到Value的数据结构
- Key 可以完整或不完整
- Key 可以是一个区间
- Value 可以是一个或多个
- Value 是最终值或值的位置
- 哈希和B+树都可以构建索引

* 数据的内存表示
- 无序数组
- 删除数组时，不移动数据
- 空闲列表
- 索引指向数组下标

* 业务查询
- 根据ID查询
- 根据姓名查询（全部或部分)
- 根据生日区间查询
- 根据男女查询

* 索引的构建
- 基于ID的Hash索引
- 基于姓名的B树索引
- 基于生日区间的B树索引
- 基于男女的位图索引

* 索引的选择
- 优先选择B树索引
- 哈希索引的效率很高，但缺乏局部性

* 索引的代价
- 额外的存储（可选）
- 降低了增删改的速度
- 不可忽视的内存占用

* 优化Name索引
- B树的每个节点还是要字符串比较的
- 姓名的特点
- 姓名倒过来存，如静张
- 如果存储的是URL效果更明显

* 优化Name的得失
- 效率更高
- 失去了按姓前缀查找
- 无法前缀压缩
- 得到的结果不直观
- 需要编程来保证这个约束
- join操作和外建约束

* 内存数据库的缺点
- 

* 优化行
- 优化前, 70+
{"ID": 1011, "Name": "王小明", "Birthday": "7月1日", "Gender": "男"}
- 优化后 
表结构文件： int, char, char, char
行数据：4 + (1 + 6) + (1 + 6) + (1 + 2) = 21  

* 优化从合适开始
- 存储选型
- 数据建模
- 具体查询
- 提前规划和过早优化
