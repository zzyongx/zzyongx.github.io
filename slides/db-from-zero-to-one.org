#+Title: 数据库系统的构建、使用、优化
#+Author: 郑志勇
#+Email: zhengzhiyong@sogou-inc.com

#+OPTIONS: reveal_width:1200 reveal_height:800
#+REVEAL_HLEVEL: 3
#+REVEAL_ROOT: /reveal.js

* 基础知识
- 数组
- 哈希
- B+树
- 算法复杂度

** 算法时间复杂度
- O(1)      array[n], 哈希
- O(N)      全表扫描
- O(logN)   B树索引
- O(N*logN) 归并排序 
- O(N*N)    集合的交、并

** 数据库背景下的复杂度
- 磁盘IO非常昂贵
- 是否顺序读取
- IO次数和IO块儿次数
- 复杂度受可用内存影响

** 算法复杂度的意义
- 结果集和IO次数的比例
- 内存消耗
- 预估查询的耗时
- 预估查询的并发

** 数据库的基本要素
- 数据
- 操作

*** 数据
- 数据量
- 业务的数据特点
- 数据的操作特点
- 优化都是基于（业务）查询和数据的分布的

*** 数据的操作
- 读
- 增
- 改（可选）
- 删（可选）

* 公司员工库
|ID|Name|Birthday |Gender |
|1011|王小明|7月1日|男|
|1012|张壮壮|3月2日|男|
|1032|张静|4月5日|女|
|1033|王丫|9月10日|女|

** 表和JSON
[{"ID": 1011, "Name": "王小明", "Birthday": "7月1日",  "Gender": "男"},

 {"ID": 1012, "Name": "张壮壮", "Birthday": "3月2日",  "Gender": "男"},

 {"ID": 1032, "Name": "张静",   "Birthday": "4月5日",  "Gender": "女"},

 {"ID": 1033, "Name": "王丫",   "Birthday": "9月10日", "Gender": "女"}]

* 文本数据库(V1)
 - 接请求，加锁，读文件
 - 反序列化，JSON
 - 增删改查
 - JSON，序列化
 - 写文件，释放锁，返回请求
 - 如有必要，返回前，同步文件到备机

** 简单，却功能完备
- 完整性
- 持久性
- 高可用

** 文本数据库的问题
- O(N) 的操作性能
- 磁盘IO浪费
- JSON浪费磁盘
- JSON序列化和反序列化浪费CPU
- 互斥锁

* 内存数据库(V2)
- (启动阶段) 加载数据，构建索引
- 接请求，读写锁
- 增删改查
- 如果有修改，写入增量文件
- 释放锁，返回请求
- 如有必要，返回前，同步增量到备机

** V1到V2的启示
- 缓存是最伟大的优化
- 缓存一致性是复杂的根源
- 预计算
- 空间换时间

** 数据的组成
- 数据文件，定期dump
- 增量文件，顺序IO
- 增量文件和数据文件合起来是全部数据
- 所有的数据放入内存（数组形式）

** 读写锁
- 并发读
- 独占写
- 粒度是表

** O(N) 的根源
- 数据的组织形式
- 数组的很多操作是O(N)的
- 基于数组的优化
- 基于其它索引的优化

** 数组

*** 数组的特点
- 位置宣示关系
- 关系表示很廉价，无需额外指针
- 维护关系可能很昂贵
[[./array.png]]

*** 基于数组的优化
- 有序
- 增 删 改 O(N)
- 二分查找 O(logN)
- 已知下标 O(1)

*** 继续数组的优化
- 大小数组
- 大数组假删
- 增，改在小数组
- 定期合并，排序O(N*logN)
- 加锁粒度的变化

*** 根据谁排序
- ID，Name，Birthday，Gender ？
- 查询决定优化
- 如果有多种查询，咋办
- 数组不能同时满足两种有序

*** 数组的启示
- 有序是关键
- 排序的是指针

** 哈希
[[./hash.png]]

*** 哈希的特点
- 无序
- 增删改查 O(1)
- 用于Hash的Key必须是确定的
- 额外的指针
- value 指向数组下标
- 缺少局部性


** B+树
[[./btree.png]]

*** B+树
- Key不必完整
- 有序
- 增删改查 O(logN)
- 额外的指针
- value 指向数组下标

** 位图索引
[[./bitmap.png]]

*** 位图索引
- Key的个数有限
- 索引非常小bits
- 索引可压缩
- 支持位图索引的数据库不多

** 索引是什么
- 根据Key找到Value的数据结构
- Key 可以完整或不完整
- Key 可以是一个区间
- Value 可以是一个或多个
- Value 是最终值或值的位置
- 哈希和B+树都可以构建索引

** 数据的内存表示
[[./mem-layout.png]]

** 数据的操作
- 无序数组
- 删除数组时，不移动数据
- 空闲列表
- 索引指向数组下标

** 业务查询
- 根据ID查询
- 根据姓名查询（全部或部分)
- 根据生日区间查询
- 根据男女查询

** 索引的构建
- 基于ID的Hash索引
- 基于姓名的B树索引
- 基于生日区间的B树索引
- 基于男女的位图索引

** 索引的选择
- 优先选择B树索引
- 哈希索引的效率很高，但缺乏局部性

** 索引的代价
- 额外的存储（可选）
- 降低了增删改的速度
- 不可忽视的内存占用

** 优化Name索引
- B树的每个节点还是要字符串比较的
- 姓名的特点
- 姓名倒过来存，如静张
- 如果存储的是URL效果更明显

** 优化Name的得失
- 效率更高
- 失去了按姓前缀查找
- 无法前缀压缩
- 得到的结果不直观
- 需要编程来保证这个约束
- join操作和外建约束

** 内存数据库的缺点
- 启动慢，数据加载和索引构建
- 冷热数据没有分级
- 数据库大小受限

* 标准数据库(V3)

** 数组和B+树
- 连续存储 vs 离散存储
- 位置联系 vs 指针联系
- 改，删 O(N) vs O(NlogN)
- 内存连续 vs 内存碎片

** 数组的改进
- 数组有序
- 大数组分成小数组（40M）
- 小数组用指针连接
- 小数组可以合并和分裂

** 数组的改进（图）
[[./array-split.png]]

** 数组和磁盘文件
- 连续存储
- 插入，删除O(N)

** 利用数组的思路改进磁盘
- Primary Key 有序
- 磁盘分块儿（文件的一段区间）
- B+树一个节点一个磁盘块儿（略小）
- 区分索引文件和数据文件
- 索引的值指向Primary Key
- 总是用到聚簇索引，只有顺序IO

** 标准数据库的数据分布
[[./disk-layout.png]]

** 聚簇索引
- Key 顺序分布在磁盘上
- IO 是连续的
- 只有一个聚簇索引

** 覆盖索引
- 不是索引类型
- select 的字段全在索引中

** JOIN
- A(M) JOIN B(N)
- 依赖统计A和B的磁盘块儿数M和N
- 磁盘IO的缘故 A * B != B * A

*** 无索引JOIN
- 扫描A，排序的小临时表
- B 同
- 归并
- 磁盘IO 2*(O(M)+O(N))

*** 索引JSON
- 索引本身有序
- 一趟归并

** 其它常见操作
- GROUP BY
- ORDER BY
- LIMIT offset,count

** 优化行存储
- 优化前, 70+
{"ID": 1011, "Name": "王小明", "Birthday": "7月1日", "Gender": "男"}
- 优化后 
表结构文件： int32, char[], int16, int8
行数据：4 + (1 + 6) + 2 + 1 = 14

* 优化从何时开始
- 存储选型
- 数据建模
- 具体查询
- 提前规划和过早优化
