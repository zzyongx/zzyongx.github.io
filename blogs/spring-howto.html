<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Spring Web Develop HOWTO</title>
<!-- 2016-04-18 一 17:11 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="root" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/styles/readtheorg/css/readtheorg.css"/>
<script src="/jslib/jquery-2.1.4.min.js"></script>
<script src="/jslib/bootstrap.min.js"></script>
<script type="text/javascript" src="/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Spring Web Develop HOWTO</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 前言</a></li>
<li><a href="#sec-2">2. Spring 解决什么问题</a>
<ul>
<li><a href="#sec-2-1">2.1. 框架的作用</a></li>
<li><a href="#sec-2-2">2.2. 程序是什么</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Spring 如何抽象输入和输出</a>
<ul>
<li><a href="#sec-3-1">3.1. 基于原生的Servlet如何编程</a></li>
<li><a href="#sec-3-2">3.2. Spring 对输入的抽象</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. RestController</a></li>
<li><a href="#sec-3-2-2">3.2.2. RequestMapping</a></li>
<li><a href="#sec-3-2-3">3.2.3. PathVariable</a></li>
<li><a href="#sec-3-2-4">3.2.4. ReqestParam</a></li>
<li><a href="#sec-3-2-5">3.2.5. CookieValue 和 RequestHeader</a></li>
<li><a href="#sec-3-2-6">3.2.6. MatrixVariable</a></li>
<li><a href="#sec-3-2-7">3.2.7. RequestBody</a></li>
<li><a href="#sec-3-2-8">3.2.8. 绑定到对象</a></li>
<li><a href="#sec-3-2-9">3.2.9. 参数校验</a></li>
<li><a href="#sec-3-2-10">3.2.10. 原生Servlet输入</a></li>
<li><a href="#sec-3-2-11">3.2.11. Spring 对 RestController 中函数原型的要求</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Spring 对输出的抽象</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. 返回String</a></li>
<li><a href="#sec-3-3-2">3.3.2. 返回对象</a></li>
<li><a href="#sec-3-3-3">3.3.3. 控制 HttpStatus 和 HttpHeader</a></li>
<li><a href="#sec-3-3-4">3.3.4. 返回void，原生Servlet输出</a></li>
<li><a href="#sec-3-3-5">3.3.5. JSONP</a></li>
<li><a href="#sec-3-3-6">3.3.6. 控制返回的Json形式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. 依赖注入 DI</a>
<ul>
<li><a href="#sec-4-1">4.1. 如何理解DI</a></li>
<li><a href="#sec-4-2">4.2. 从单例到DI</a></li>
<li><a href="#sec-4-3">4.3. Spring DI 包括哪些组成部分</a></li>
<li><a href="#sec-4-4">4.4. 实例讲解DI</a>
<ul>
<li><a href="#sec-4-4-1">4.4.1. MemoController 有注入需求</a></li>
<li><a href="#sec-4-4-2">4.4.2. MemoManager 提供了注入能力</a></li>
<li><a href="#sec-4-4-3">4.4.3. DI 是递归的</a></li>
</ul>
</li>
<li><a href="#sec-4-5">4.5. 以上只是猜测</a></li>
<li><a href="#sec-4-6">4.6. 给单例对象命名</a></li>
<li><a href="#sec-4-7">4.7. @Bean注解函数</a></li>
<li><a href="#sec-4-8">4.8. @Autowired 和静态函数、静态成员变量</a></li>
<li><a href="#sec-4-9">4.9. Component 的局限性</a></li>
<li><a href="#sec-4-10">4.10. 线程安全</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 扔掉 XML 配置</a>
<ul>
<li><a href="#sec-5-1">5.1. 配置什么？</a></li>
<li><a href="#sec-5-2">5.2. url和处理函数的映射</a></li>
<li><a href="#sec-5-3">5.3. 配置Servlet上下文</a></li>
<li><a href="#sec-5-4">5.4. 配置应用上下文</a></li>
<li><a href="#sec-5-5">5.5. 配置文件</a></li>
<li><a href="#sec-5-6">5.6. @Profile</a></li>
<li><a href="#sec-5-7">5.7. 创建一个Bean来做相应的配置</a></li>
<li><a href="#sec-5-8">5.8. 集成一个类来做相应的配置</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 异常处理</a>
<ul>
<li><a href="#sec-6-1">6.1. 无处不在的异常</a></li>
<li><a href="#sec-6-2">6.2. 无能为力的异常</a></li>
<li><a href="#sec-6-3">6.3. Spring的异常观</a></li>
<li><a href="#sec-6-4">6.4. 统一的异常处理</a></li>
</ul>
</li>
<li><a href="#sec-7">7. RestTemplate</a></li>
<li><a href="#sec-8">8. 数据库相关</a>
<ul>
<li><a href="#sec-8-1">8.1. 名目繁多的ORM</a></li>
<li><a href="#sec-8-2">8.2. 配置DataSource</a></li>
<li><a href="#sec-8-3">8.3. JdbcTemplate</a></li>
<li><a href="#sec-8-4">8.4. 事务</a>
<ul>
<li><a href="#sec-8-4-1">8.4.1. Transactional</a></li>
<li><a href="#sec-8-4-2">8.4.2. TransactionTemplate</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-9">9. 性能监控和slf4j</a></li>
<li><a href="#sec-10">10. API 文档</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 前言</h2>
<div class="outline-text-2" id="text-1">
<p>
2015年10月以前，我做c，c++，perl，lua开发，一直崇尚简洁。虽然很早就读过 thinking in java，但是一直没有涉足java开发，java给我两个感觉，一是笨重，而是庞杂，这里面有各种框架的功劳，看到诸多形形色色的框架，就不寒而栗。
</p>

<p>
2015年10月以后，终于不得不接触java开发，首当其冲的就是spring。一开始就被各种概念整懵了，IOC，DI，AOP，完全搞不懂这些东西是干啥的，也不知道引入它们的目的。徘徊了一个月，终于恍然大悟，spring其实很简单，如果有人点拨，学习spring的过程不至于这么曲折。随后，面试了一些java开发者，发现大家都知道spring，但是对spring的理解和使用都比较肤浅。本文试图由浅入深的讲解spring的本质是啥，如何最大限度的利用spring。
</p>

<p>
本文基于Spring4，主要讲解Rest风格的编程，不涉及到View部分。本文也不求面面俱到，只求领人入门，有更复杂的需求，尽可以翻看文档，Spring不会让你失望，只有想不到，没有做不到。
</p>

<p>
本文所有代码都可以从<a href="https://github.com/zzyongx/c-gist/tree/master/java/howto">这里</a> 下载。
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Spring 解决什么问题</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 框架的作用</h3>
<div class="outline-text-3" id="text-2-1">
<p>
框架五花八门，无处不在，框架解决的问题各式各样，但从编程实践的角度来看，框架是为了让程序更优雅。
</p>

<ul class="org-ul">
<li>框架消除重复代码
</li>
<li>框架消除相似代码
</li>
</ul>

<p>
框架是一种抽象，抽象层次越高，上述好处越多，当然，可能相应的灵活性就少很多。
</p>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 程序是什么</h3>
<div class="outline-text-3" id="text-2-2">
<p>
这个问题似乎太简单，但一时又不知从何说起。先看个简单的程序，hello.pl
</p>
<div class="org-src-container">

<pre class="src src-perl"><span style="color: #ffff00;">#</span><span style="color: #ffff00;">!/usr/bin/perl</span>
<span style="color: #00ffff; font-weight: bold;">my</span> <span style="color: #ffff00;">$name</span> = <span style="color: #ff83fa;">shift</span> || <span style="color: #00ff00;">"friend s"</span>;
<span style="color: #ff83fa;">print</span> <span style="color: #00ff00;">"hello $name\n"</span>;
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">$ ./hello.pl spring
hello spring
</pre>
</div>

<p>
这个程序异常简单，它接受字符串，输出字符串。那么复杂的程序呢？我们考虑http服务器，比如jetty，它的输入输出是什么？
</p>

<pre class="example">
# curl http://dev/api/login?jsonp=x -vv
&gt; GET /api/login?jsonp=x HTTP/1.1
&gt; User-Agent: curl/7.41.0
&gt; Host: dev
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Server: nginx/1.8.0
&lt; Date: Thu, 31 Dec 2015 02:43:19 GMT
&lt; Content-Type: application/javascript
&lt; Transfer-Encoding: chunked
&lt; Connection: keep-alive
&lt; X-Content-Type-Options: nosniff
&lt; X-XSS-Protection: 1; mode=block
&lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&lt; Pragma: no-cache
&lt; Expires: 0
&lt; X-Frame-Options: DENY
&lt;
/**/x({"code":400,"message":"bad request","data":{"password":"password is required"}});
</pre>

<p>
这里我们用curl模拟http请求， <code>输入点</code> 包括
</p>
<ul class="org-ul">
<li>HTTP Method，这里是 <code>GET</code> ，此外常用的还有 <code>POST PUT DELETE</code>
</li>
<li>请求 <code>url</code> ，包括 <code>path</code> 这里是 <code>/api/login</code> ，和 <code>querystring</code> ，这里是 <code>jsonp=x</code> , <code>querystring</code> 是可选的
</li>
<li>请求 <code>header</code> ，例如 Host，Accept，有些header比其它header要重要一些，比如cookie。
</li>
<li>请求 <code>body</code> ，这里body为空，一般请求 <code>POST PUT</code> 才需要body。
</li>
</ul>

<p>
<code>输出点</code> 包括：
</p>
<ul class="org-ul">
<li>HTTP code，这里是 ~200~。
</li>
<li>响应 <code>header</code> ，例如 Content-Type
</li>
<li>响应 <code>body</code> ，这里是 <i>**</i>开头的行
</li>
</ul>

<p>
上面的 <code>输入</code> 通过 <code>tcp</code> 协议传送给jetty，jetty通过 <code>tcp</code> 协议将 <code>输出</code> 回传给用户。这里针对输入和输出的规定，构成了 <code>http</code> 协议的内容， <code>http</code> 协议并没有规定输出 <code>body</code> 的格式。
</p>

<p>
从简单的 HelloWorld，到复杂的Web应用，程序的功能，无非都是解析输入，产生输出。程序使用程序语言编写的，程序语言规定了数据类型（结构），程序中的逻辑都是通过操作程序支持的数据类型实现的。我们需要在程序开始时，把输入转成程序语言支持的数据类型，在程序结束时，把程序语言支持的数据类型转成响应的输出。
</p>

<p>
对 HelloWorld 而言， <code>输入点</code> 很简单，是一个命令行参数，对Web应用而言， <code>输入点</code> 就复杂很多，如何把 <code>输入点</code> 的数据转成编程语言支持的数据类型，正是框架做的事情。
</p>

<p>
除了数据转换，框架还提供了机制，可以校验数据有效性。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Spring 如何抽象输入和输出</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 基于原生的Servlet如何编程</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Servlet是一套标准，java开发者可以使用它开发WEB应用，运行Servlet的web服务器称为Servlet容器，常见的Servlet容器有jetty，tomcat等。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">HelloWorld</span> <span style="color: #00ffff; font-weight: bold;">extends</span> <span style="color: #00ff00;">HttpServlet</span> 
{
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">doGet</span>(<span style="color: #00ff00;">HttpServletRequest</span> <span style="color: #ffff00;">request</span>,
                    <span style="color: #00ff00;">HttpServletResponse</span> <span style="color: #ffff00;">response</span>)
            <span style="color: #00ffff; font-weight: bold;">throws</span> <span style="color: #00ff00;">ServletException</span>, <span style="color: #00ff00;">IOException</span> {
    <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">name</span> = request.getParameter(<span style="color: #00ff00;">"name"</span>);
    response.setContentType(<span style="color: #00ff00;">"text/html"</span>);

    <span style="color: #ffff00;">// </span><span style="color: #ffff00;">Actual logic goes here.</span>
    <span style="color: #00ff00;">PrintWriter</span> <span style="color: #ffff00;">out</span> = response.getWriter();
    out.println(<span style="color: #00ff00;">"&lt;h1&gt; Hello "</span> + name + <span style="color: #00ff00;">"&lt;/h1&gt;"</span>);
  }
}
</pre>
</div>

<p>
除了上述函数，我们还需要在 web.xml 配置url和处理函数的对应关系
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #0000ff; font-weight: bold;">servlet</span>&gt;
   &lt;<span style="color: #0000ff; font-weight: bold;">servlet-name</span>&gt;HelloWorld&lt;/<span style="color: #0000ff; font-weight: bold;">servlet-name</span>&gt;
   &lt;<span style="color: #0000ff; font-weight: bold;">servlet-class</span>&gt;HelloWorld&lt;/<span style="color: #0000ff; font-weight: bold;">servlet-class</span>&gt;
&lt;/<span style="color: #0000ff; font-weight: bold;">servlet</span>&gt;

&lt;<span style="color: #0000ff; font-weight: bold;">servlet-mapping</span>&gt;
   &lt;<span style="color: #0000ff; font-weight: bold;">servlet-name</span>&gt;HelloWorld&lt;/<span style="color: #0000ff; font-weight: bold;">servlet-name</span>&gt;
   &lt;<span style="color: #0000ff; font-weight: bold;">url-pattern</span>&gt;/HelloWorld&lt;/<span style="color: #0000ff; font-weight: bold;">url-pattern</span>&gt;
&lt;/<span style="color: #0000ff; font-weight: bold;">servlet-mapping</span>&gt;
</pre>
</div>

<p>
这个过程非常直观，Servlet容器收到WEB请求，根据url和web.xml的配置，选择相应的处理类处理。使用 <code>HttpServletRequest HttpServletResponse</code> 表示输入和输出，这个抽象层次太低了，本例中为了获取 <code>querystring</code> 中的name参数，需要调用相应的函数。如果可以直接把 <code>querystring</code> 中的name参数绑定到一个 <b>String类型的变量</b> 抽象层次就高很多。
</p>

<p>
另外url和url处理类在不同的地方，不能一眼看出url的处理逻辑。
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Spring 对输入的抽象</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Spring提供了非常简单的机制，将 <code>输入点</code> 的数据转成java支持的数据类型， <code>long String List class</code> 等。
</p>
<ul class="org-ul">
<li>通过 <code>RestController</code> 和 <code>RequestMapping</code> 将 url 映射到具体的处理函数
</li>
<li>通过 <code>PathVariable</code> 和 <code>RequestParam</code> 将url的内容和querystring映射到java变量
</li>
<li>把 querystring 映射成java对象
</li>
<li>通过 <code>RequestHeader</code> 把 <code>header</code> 的值映射为java变量
</li>
</ul>

<p>
此外可以组合使用上述方法。如下代码将详细讲述映射（绑定）是如何发生的。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@RestController</span>
<span style="color: #ff00ff;">@RequestMapping</span>(<span style="color: #00ff00;">"/api"</span>)
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">EchoController</span> {

  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">static</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">Profile</span> {
    <span style="color: #ff00ff;">@NotBlank</span>(message = <span style="color: #00ff00;">"name is required"</span>)
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">name</span>;

    <span style="color: #ff00ff;">@Pattern</span>(regexp = <span style="color: #00ff00;">"\\d{11,15}"</span>, message = <span style="color: #00ff00;">"phone is required"</span>)
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">phone</span>;

    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">List</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">favoriteColor</span>;

    <span style="color: #ff00ff;">@DateTimeFormat</span>(pattern = <span style="color: #00ff00;">"yyyy-MM-dd'T'HH:mm:ss"</span>)
    <span style="color: #ff00ff;">@JsonSerialize</span>(using = LocalDateTimeJsonSerializer.<span style="color: #00ffff; font-weight: bold;">class</span>)
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">LocalDateTime</span> <span style="color: #ffff00;">birthday</span>;

    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">setName</span>(<span style="color: #00ff00;">String</span> <span style="color: #ffff00;">name</span>) {
      <span style="color: #00ffff; font-weight: bold;">this</span>.name = name;
    }
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">setPhone</span>(<span style="color: #00ff00;">String</span> <span style="color: #ffff00;">phone</span>) {
      <span style="color: #00ffff; font-weight: bold;">this</span>.phone = phone;
    }
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">setFavoriteColor</span>(<span style="color: #00ff00;">List</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">color</span>) {
      <span style="color: #00ffff; font-weight: bold;">this</span>.favoriteColor = color;
    }
    <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">setBirthday</span>(<span style="color: #00ff00;">LocalDateTime</span> <span style="color: #ffff00;">birthday</span>) {
      <span style="color: #00ffff; font-weight: bold;">this</span>.birthday = birthday;
    }
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">OptionalLong is not support now, use Optional&lt;Long&gt; instead of</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/power/5</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/power/5/3</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = {<span style="color: #00ff00;">"/power/{base}"</span>, <span style="color: #00ff00;">"/power/{base}/{power}"</span>}, method = <span style="color: #ff00ff;">RequestMethod</span>.GET)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">long</span> <span style="color: #0000ff; font-weight: bold;">getPower</span>(<span style="color: #ff00ff;">@PathVariable</span> <span style="color: #00ff00;">long</span> <span style="color: #ffff00;">base</span>, <span style="color: #ff00ff;">@PathVariable</span>(<span style="color: #00ff00;">"power"</span>) <span style="color: #00ff00;">Optional</span>&lt;<span style="color: #00ff00;">Long</span>&gt; <span style="color: #ffff00;">powerOpt</span>) {
    <span style="color: #00ff00;">long</span> <span style="color: #ffff00;">power</span> = powerOpt.orElse(2L);
    <span style="color: #00ffff; font-weight: bold;">return</span> (<span style="color: #00ff00;">long</span>) Math.pow(base, power);
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/upper/hello</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/upper?qs=world</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = {<span style="color: #00ff00;">"/upper"</span>, <span style="color: #00ff00;">"/upper/{upper}"</span>}, method = <span style="color: #ff00ff;">RequestMethod</span>.GET)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">String</span> <span style="color: #0000ff; font-weight: bold;">getUpper</span>(
    <span style="color: #ff00ff;">@PathVariable</span> <span style="color: #00ff00;">Optional</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">upper</span>,
    <span style="color: #ff00ff;">@RequestParam</span>(required = <span style="color: #ff00ff;">false</span>, defaultValue = <span style="color: #00ff00;">"Hello world"</span>) <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">qs</span>) {
    <span style="color: #00ffff; font-weight: bold;">if</span> (upper.isPresent()) <span style="color: #00ffff; font-weight: bold;">return</span> upper.get().toUpperCase();
    <span style="color: #00ffff; font-weight: bold;">return</span> qs.toUpperCase();
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/books -H "Accept: text/plain"</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/books"</span>, produces = <span style="color: #00ff00;">"text/plain"</span>)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">String</span> <span style="color: #0000ff; font-weight: bold;">getBooksText</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ff00;">"Mastering Spring MVC,Spring in Action"</span>;
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/books</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/books"</span>)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">List</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #0000ff; font-weight: bold;">getBooks</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> Arrays.asList(<span style="color: #00ff00;">"Mastering Spring MVC"</span>, <span style="color: #00ff00;">"Spring in Action"</span>);
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl -X PUT dev:8180/api/profile -d '{"name": "zzyong", "phone": 12345678901}' -H "Content-Type: application/octet-stream"</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/profile"</span>, method = <span style="color: #ff00ff;">RequestMethod</span>.PUT,
                  consumes = <span style="color: #00ff00;">"application/octet-stream"</span>)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">submitProfile</span>(<span style="color: #00ff00;">HttpServletRequest</span> <span style="color: #ffff00;">request</span>, <span style="color: #00ff00;">HttpServletResponse</span> <span style="color: #ffff00;">response</span>)
    <span style="color: #00ffff; font-weight: bold;">throws</span> <span style="color: #00ff00;">IOException</span> {
    <span style="color: #00ff00;">InputStream</span> <span style="color: #ffff00;">input</span> = request.getInputStream();
    <span style="color: #00ff00;">OutputStream</span> <span style="color: #ffff00;">output</span> = response.getOutputStream();

    <span style="color: #00ff00;">byte</span>[] <span style="color: #ffff00;">buffer</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">byte</span>[512];
    <span style="color: #00ff00;">int</span> <span style="color: #ffff00;">n</span>;
    <span style="color: #00ffff; font-weight: bold;">while</span> ((n = input.read(buffer)) &gt; 0) {
      output.write(buffer, 0, n);
    }
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl -X PUT dev:8180/api/profile -d '{"name": "zzyong", "phone": 12345678901}' -H "Content-Type: application/json"  </span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/profile"</span>, method = <span style="color: #ff00ff;">RequestMethod</span>.PUT, consumes = <span style="color: #00ff00;">"application/json"</span>)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">String</span> <span style="color: #0000ff; font-weight: bold;">submitProfileJson</span>(<span style="color: #ff00ff;">@RequestBody</span> <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">json</span>) {
    <span style="color: #00ffff; font-weight: bold;">return</span> json;
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl -X PUT "dev:8180/api/profile" -d 'name=zzyong&amp;phone=12345678901&amp;favoriteColor=red,green' -vv</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">Content-Type: application/x-www-form-urlencoded</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl -X PUT "dev:8180/api/profile" -F 'name=zzyong' -F 'phone=12345678901' -F 'favoriteColor=red,green' -vv</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">Content-Type: multipart/form-data; boundary=------------------------c00a4e11cd9e4e67</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/profile"</span>, method= <span style="color: #ff00ff;">RequestMethod</span>.PUT)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">ResponseEntity</span> <span style="color: #0000ff; font-weight: bold;">submitProfileForm</span>(<span style="color: #ff00ff;">@Valid</span> <span style="color: #00ff00;">Profile</span> <span style="color: #ffff00;">profile</span>, <span style="color: #00ff00;">BindingResult</span> <span style="color: #ffff00;">bindingResult</span>) {
    <span style="color: #00ffff; font-weight: bold;">if</span> (bindingResult.hasErrors()) {
      <span style="color: #00ff00;">Map</span>&lt;<span style="color: #00ff00;">String</span>, <span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">map</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">HashMap</span>&lt;&gt;();
      <span style="color: #00ffff; font-weight: bold;">for</span>(<span style="color: #00ff00;">FieldError</span> <span style="color: #ffff00;">error</span> : bindingResult.getFieldErrors()){
        map.put(error.getField(), error.getDefaultMessage());
      }
      <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">ResponseEntity</span>&lt;<span style="color: #00ff00;">Map</span>&gt;(map, <span style="color: #ff00ff;">HttpStatus</span>.BAD_REQUEST);      
    } <span style="color: #00ffff; font-weight: bold;">else</span> {
      <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">ResponseEntity</span>&lt;<span style="color: #00ff00;">Profile</span>&gt;(profile, <span style="color: #ff00ff;">HttpStatus</span>.OK);
    }
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl "dev:8180/api/profile" -H "user: bob" -H "password: secret" -vv</span>
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl "dev:8180/api/profile" -H "Cookie: uid=btxaergfe" -vv</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/profile"</span>, method = <span style="color: #ff00ff;">RequestMethod</span>.GET)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">Profile</span> <span style="color: #0000ff; font-weight: bold;">getProfile</span>(
    <span style="color: #ff00ff;">@CookieValue</span>(<span style="color: #00ff00;">"uid"</span>) <span style="color: #00ff00;">Optional</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">uid</span>,
    <span style="color: #ff00ff;">@RequestHeader</span>(<span style="color: #00ff00;">"user"</span>) <span style="color: #00ff00;">Optional</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">user</span>,
    <span style="color: #ff00ff;">@RequestHeader</span>(<span style="color: #00ff00;">"password"</span>) <span style="color: #00ff00;">Optional</span>&lt;<span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">pass</span>) {
    <span style="color: #00ff00;">Profile</span> <span style="color: #ffff00;">profile</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">Profile</span>();
    profile.name = <span style="color: #00ff00;">"bob"</span>;
    <span style="color: #00ffff; font-weight: bold;">if</span> (uid.isPresent() || (user.isPresent() &amp;&amp; pass.isPresent())) {
      profile.phone = <span style="color: #00ff00;">"31415926535"</span>;
      <span style="color: #00ffff; font-weight: bold;">return</span> profile;
    } <span style="color: #00ffff; font-weight: bold;">else</span> {
      <span style="color: #00ffff; font-weight: bold;">return</span> profile;
    }
  }

  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">curl dev:8180/api/x/100;name=apple;color=red/y/200;name=orange</span>
  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/x/{x}/y/{y}"</span>)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">Map</span> <span style="color: #0000ff; font-weight: bold;">coordinateProfile</span>(
    <span style="color: #ff00ff;">@PathVariable</span> <span style="color: #00ff00;">int</span> <span style="color: #ffff00;">x</span>, <span style="color: #ff00ff;">@MatrixVariable</span>(pathVar = <span style="color: #00ff00;">"x"</span>) <span style="color: #00ff00;">Map</span>&lt;<span style="color: #00ff00;">String</span>, <span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">xCnf</span>,
    <span style="color: #ff00ff;">@PathVariable</span> <span style="color: #00ff00;">int</span> <span style="color: #ffff00;">y</span>, <span style="color: #ff00ff;">@MatrixVariable</span>(pathVar = <span style="color: #00ff00;">"y"</span>) <span style="color: #00ff00;">Map</span>&lt;<span style="color: #00ff00;">String</span>, <span style="color: #00ff00;">String</span>&gt; <span style="color: #ffff00;">yCnf</span>) {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">HashMap</span>&lt;<span style="color: #00ff00;">Integer</span>, <span style="color: #00ff00;">Map</span>&gt;() {{
      put(x, xCnf);
      put(y, yCnf);
    }};
  }
}
</pre>
</div>
</div>

<div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> RestController</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
通过RestController标注， <code>EchoController</code> 中相应的函数会成为相应url的处理函数。
</p>
</div>
</div>

<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> RequestMapping</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
当RequestMapping用来标类时，相应的path成为该类中，所有url的前缀，本例中所有url都自动加 /api 前缀。
RequestMapping 常用参数如下：
</p>
<ul class="org-ul">
<li>value 指定url，可以指定多个，如 <code>getPower</code> 和 <code>getUpper</code>
</li>
<li>method 指定 HTTP 方法，默认不限制
</li>
<li>produces 指定 Accept，只有Accept符合的请求才接受
</li>
<li>consumes 指定 Content-Type，只有Content-Type符合的请求才接受
</li>
</ul>

<p>
当同一个url可以产生多种格式的输出时，请求通过 <code>Accept</code> 头指定接受的格式，选择匹配的 <code>produces</code> 处理函数，产生相应输出。
</p>

<p>
例如，指定 <code>Accept</code> 只接受文本格式时，/api/books 返回逗号分隔的字符串，默认返回json。
</p>
<div class="org-src-container">

<pre class="src src-sh">$ curl dev:8180/api/books -H <span style="color: #00ff00;">"Accept: text/plain"</span>
Mastering Spring MVC,Spring<span style="color: #00ffff; font-weight: bold;"> in</span> Action

$ curl dev:8180/api/books
[<span style="color: #00ff00;">"Mastering Spring MVC"</span>,<span style="color: #00ff00;">"Spring in Action"</span>]
</pre>
</div>

<p>
当同一个url接受多种格式的输入时，请求通过 <code>Content-Type</code> 指定输入的格式，选择匹配的 <code>consumes</code> 处理函数。
</p>

<p>
例如，指定 <code>Content-Type</code> 为 application<i>json 时，可以输入原生的Json数据，而不指定可以接受任意类型。这个主要影响数据绑定，Spring支持Content-Type为 application</i>x-www-form-urlencoded 和 multipart/form-data 的绑定
</p>

<div class="org-src-container">

<pre class="src src-sh">$ curl -X PUT dev:8180/api/profile -d <span style="color: #00ff00;">'{"name": "zzyong", "phone": 12345678901}'</span> -H <span style="color: #00ff00;">"Content-Type: application/json"</span>
{<span style="color: #00ff00;">"name"</span>: <span style="color: #00ff00;">"zzyong"</span>, <span style="color: #00ff00;">"phone"</span>: 12345678901}

$ curl -X PUT dev:8180/api/profile -d <span style="color: #00ff00;">'name=zzyong&amp;phone=12345678901&amp;favoriteColor=red,green'</span>
{<span style="color: #00ff00;">"name"</span>:<span style="color: #00ff00;">"zzyong"</span>,<span style="color: #00ff00;">"phone"</span>:<span style="color: #00ff00;">"12345678901"</span>,<span style="color: #00ff00;">"favoriteColor"</span>:[<span style="color: #00ff00;">"red"</span>,<span style="color: #00ff00;">"green"</span>]}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> PathVariable</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
<code>PathVariable</code> 用于绑定url模板中的参数，它只有一个参数，用于指定变量在url模板的名字。
</p>

<p>
在 <code>getPower</code> 中，url模板为 {"<i>power/{base}", "</i>power/{base}/{power}"}，变量base的名字和{base}相同，而变量powerOpt和{power}不同，所以使用 <code>@PathVariable("power")</code> 指定模板的名字。
</p>

<p>
此外， <code>RequestMapping</code> 指定了两个url，power是可选的，此时可以使用Java8的新特性，Optional。虽然Java8提供了 OptionLong 作为 Optional&lt;Long&gt; 的优化，似乎目前spring并不支持前者。
</p>
</div>
</div>

<div id="outline-container-sec-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> ReqestParam</h4>
<div class="outline-text-4" id="text-3-2-4">
<p>
<code>RequestParam</code> 用于绑定 <code>querystring</code> 和 <code>requestbody</code> 中的参数，其主要参数有
</p>
<ul class="org-ul">
<li>required 指定参数是否必须，默认为ture
</li>
<li>defaultValue 当required为false时，指定默认值，必须是字符串串，和绑定变量的类型无关。例如 1 写成 "1"
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> CookieValue 和 RequestHeader</h4>
<div class="outline-text-4" id="text-3-2-5">
<p>
<code>CooieValue</code> 用于绑定 <code>Cookie</code> 中的某一个， <code>RequestHeader</code> 用于绑定header
在 getProfile 中，用了Optional，因为这些都是可选的。
</p>
</div>
</div>

<div id="outline-container-sec-3-2-6" class="outline-4">
<h4 id="sec-3-2-6"><span class="section-number-4">3.2.6</span> MatrixVariable</h4>
<div class="outline-text-4" id="text-3-2-6">
<p>
<code>MatrixVariable</code> 用于获取url的某段path的选项，默认是关闭的，需要通过一个配置打开，具体来说就是创建一个 <code>Bean</code> 。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Bean</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">RequestMappingHandlerMapping</span> <span style="color: #0000ff; font-weight: bold;">requestMappingHandlerMapping</span>() {
  <span style="color: #00ff00;">RequestMappingHandlerMapping</span> <span style="color: #ffff00;">r</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">RequestMappingHandlerMapping</span>();
  r.setRemoveSemicolonContent(<span style="color: #ff00ff;">false</span>);
  <span style="color: #00ffff; font-weight: bold;">return</span> r;
}
</pre>
</div>

<p>
<code>MatrixVariable</code> 主要参数是一个 <code>pathVar</code> 用于指定相应的url模板部分，如果不指定，全部的matrix都会放到一个 <code>Map</code> 中去。
</p>

<p>
<code>MatrixVariable</code> 只是请求url有所不同，并不影响 <code>RequestMapping</code> 的形式。例如 x<i>{x}</i>y/{y} 可以映射下面的请求
</p>

<div class="org-src-container">

<pre class="src src-sh">$ curl <span style="color: #00ff00;">'http://dev:8180/api/x/100;name=apple;color=red/y/200;name=orange'</span>
{<span style="color: #00ff00;">"100"</span>:{<span style="color: #00ff00;">"name"</span>:[<span style="color: #00ff00;">"apple"</span>],<span style="color: #00ff00;">"color"</span>:[<span style="color: #00ff00;">"red"</span>]},<span style="color: #00ff00;">"200"</span>:{<span style="color: #00ff00;">"name"</span>:[<span style="color: #00ff00;">"orange"</span>]}}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-7" class="outline-4">
<h4 id="sec-3-2-7"><span class="section-number-4">3.2.7</span> RequestBody</h4>
<div class="outline-text-4" id="text-3-2-7">
<p>
对于 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data</code> 的请求，通常会把 <code>requestbody</code> 以key-value的形式绑定到各个变量。但有时需要获取整个 <code>requestbody</code> 的内容，此时可以用 <code>RequestBody</code> ，如 <code>submitProfileJson</code> 所示。
</p>

<p>
对于 <code>Content-Type</code> 为 <code>application/json</code> 的请求， <code>requestbody</code> 是Json，会自动解析为对象。此时最好设置 consumes 为 "application/json"
</p>
</div>
</div>

<div id="outline-container-sec-3-2-8" class="outline-4">
<h4 id="sec-3-2-8"><span class="section-number-4">3.2.8</span> 绑定到对象</h4>
<div class="outline-text-4" id="text-3-2-8">
<p>
<code>submitProfileForm</code> 的参数是 <code>(@Valid Profile profile, BindingResult bindingResult)</code> ，spring会把 <code>querystring</code> 和 <code>requestbody</code> 中的值绑定到 <code>Profile</code> 。假如 <code>requestbody</code> 是 <code>name=zzyong&amp;phone=12345678901&amp;favoriteColor=red,green</code> ，spring解析到name时，会调用Profile的 <code>setName</code> 函数，解析到favoriteColor时，会调用 <code>setFavoriteColor</code> 。注意 Profile中的相关字段，必须有set方法，仅仅是public时不够的。
</p>

<p>
除了基本的类型转换，String转long String转时间， <b>逗号分隔</b> 的字符串，也会被转成List。
</p>
</div>
</div>

<div id="outline-container-sec-3-2-9" class="outline-4">
<h4 id="sec-3-2-9"><span class="section-number-4">3.2.9</span> 参数校验</h4>
<div class="outline-text-4" id="text-3-2-9">
<p>
使用场景参考 <code>Profile</code> 和 <code>submitProfileForm</code> ，可选的校验类型与spring无关，常见的校验
</p>
<ul class="org-ul">
<li>DateTimeFormat @DateTimeFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
</li>
<li>Pattern @Pattern(regexp = "\\d{11,15}")
</li>
<li>NotBlank
</li>
<li>NotNull
</li>
<li>Min Max
</li>
<li>Size
</li>
</ul>

<p>
Valid 用于校验参数的合法性，并把校验结果存放到 <code>BindingResult</code> 中。 例如：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ curl -X PUT <span style="color: #00ff00;">"dev:8180/api/profile"</span> -d <span style="color: #00ff00;">'phone=12345678901&amp;favoriteColor=red,green'</span>
{<span style="color: #00ff00;">"name"</span>:<span style="color: #00ff00;">"name is required"</span>}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-2-10" class="outline-4">
<h4 id="sec-3-2-10"><span class="section-number-4">3.2.10</span> 原生Servlet输入</h4>
<div class="outline-text-4" id="text-3-2-10">
<p>
如果上述绑定满足不了需求，仍然可以获得类似 <code>Servlet</code> 的参数，如 <code>submitProfileStream</code> 所示。
</p>
</div>
</div>

<div id="outline-container-sec-3-2-11" class="outline-4">
<h4 id="sec-3-2-11"><span class="section-number-4">3.2.11</span> Spring 对 RestController 中函数原型的要求</h4>
<div class="outline-text-4" id="text-3-2-11">
<p>
有过 <code>Servlet</code> 编程经验的人，初次看到 <code>RestController</code> 的代码，可能会惊讶于函数签名的千奇百怪。的确，很多框架，都是要求使用者继承一个类，覆盖一些方法，或者实现一些接口，函数原型并没有选择的余地。Spring不是这样， <code>RestController</code> 中的函数原型是任意的，Spring会根据注解和变量类型，做正确的函数调用。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Spring 对输出的抽象</h3>
<div class="outline-text-3" id="text-3-3">
<p>
相对输入，输出就简单很多，主要涉及到把java <code>对象</code> 转成 <code>responsebody</code> 也就是字符串。字符串自身的格式有普通文本，Json，Xml等多种选择，现在的web应用基本以Json为主。
参考以下配置，如果返回字符串，原样返回，如果其它，转成Json字符串。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">WebConfig</span> <span style="color: #00ffff; font-weight: bold;">extends</span> <span style="color: #00ff00;">WebMvcConfigurerAdapter</span> {
  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">configureMessageConverters</span>(<span style="color: #00ff00;">List</span>&lt;<span style="color: #00ff00;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #ffff00;">converters</span>) {
    <span style="color: #ffff00;">/* </span><span style="color: #ffff00;">string convert must be first */</span>
    converters.add(<span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">StringHttpMessageConverter</span>());

    <span style="color: #00ff00;">Jackson2ObjectMapperBuilder</span> <span style="color: #ffff00;">builder</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">Jackson2ObjectMapperBuilder</span>();
    builder.featuresToDisable(<span style="color: #ff00ff;">SerializationFeature</span>.WRITE_DATES_AS_TIMESTAMPS);
    builder.featuresToDisable(<span style="color: #ff00ff;">SerializationFeature</span>.FAIL_ON_EMPTY_BEANS);
    builder.serializationInclusion(<span style="color: #ff00ff;">JsonInclude</span>.<span style="color: #ff00ff;">Include</span>.NON_NULL);
    converters.add(<span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">MappingJackson2HttpMessageConverter</span>(builder.build()));
  }
}
</pre>
</div>
</div>

<div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> 返回String</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
参考 <code>getUpper</code> 返回值是 <code>String</code> ，则 <code>responsebody</code> 就是返回的值。
此处依赖配置 <code>StringHttpMessageConverter</code> 。假设返回Hello，如果没有该配置，则 <code>responsebody</code> 是 <b>"Hello"</b> ，而不是 <b>Hello</b> ，前者是字符串的Json形式。
</p>
</div>
</div>

<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> 返回对象</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
参考 <code>getBooks</code> 和 <code>getProfile</code> ，无论是Java的容器，还是普通 <code>类</code> ，都可以自动转成合适的Json形式。
</p>
</div>
</div>

<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> 控制 HttpStatus 和 HttpHeader</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
<code>ResponseEntity</code> 是一个特殊的对象，返回它时不会把它自身转成Json，它自身控制了 <code>Status Header Body</code> ，通过相应的构造函数，控制相应的部分
</p>
<ul class="org-ul">
<li>ResponseEntity(HttpStatus statusCode)
</li>
<li>ResponseEntity(MultiValueMap&lt;String,String&gt; headers, HttpStatus statusCode)
</li>
<li>ResponseEntity(T body, HttpStatus statusCode)
</li>
<li>ResponseEntity(T body, MultiValueMap&lt;String,String&gt; headers, HttpStatus statusCode)
</li>
</ul>

<p>
T 是任意对象，会被转成Json。 <code>submitProfileForm</code> 就是通过 <code>ResponseEntity</code> 返回400的
</p>
</div>
</div>

<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4"><span class="section-number-4">3.3.4</span> 返回void，原生Servlet输出</h4>
<div class="outline-text-4" id="text-3-3-4">
<p>
通过 <code>HttpServletResponse</code> 可以控制所有输出，此时函数返回void。
</p>
</div>
</div>

<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5"><span class="section-number-4">3.3.5</span> JSONP</h4>
<div class="outline-text-4" id="text-3-3-5">
<p>
<a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a> 用来克服浏览器的跨域限制。通常接口返回Json数据，而JSONP返回对Json数据的函数调用。例如：
</p>
<div class="org-src-container">

<pre class="src src-sh">$ curl <span style="color: #00ff00;">"dev:8180/api/books"</span>
[<span style="color: #00ff00;">"Mastering Spring MVC"</span>,<span style="color: #00ff00;">"Spring in Action"</span>]

$ curl <span style="color: #00ff00;">"dev:8180/api/books?jsonp=display"</span>
/**/display([<span style="color: #00ff00;">"Mastering Spring MVC"</span>,<span style="color: #00ff00;">"Spring in Action"</span>]);
</pre>
</div>

<p>
<code>getBooks</code> 函数并没有根据 <code>jsonp</code> 参数做任何特殊处理，但是带 <code>jsonp</code> 参数的请求返回的是函数调用，这都是Spring支持的，为了启用该支持，需要增加下面的代码。
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@ControllerAdvice</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">JsonpAdvice</span> <span style="color: #00ffff; font-weight: bold;">extends</span> <span style="color: #00ff00;">AbstractJsonpResponseBodyAdvice</span> {
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #0000ff; font-weight: bold;">JsonpAdvice</span>() {
    <span style="color: #00ffff; font-weight: bold;">super</span>(<span style="color: #00ff00;">"jsonp"</span>);
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3-6" class="outline-4">
<h4 id="sec-3-3-6"><span class="section-number-4">3.3.6</span> 控制返回的Json形式</h4>
<div class="outline-text-4" id="text-3-3-6">
<p>
Spring提供了<code>Jackson2ObjectMapperBuilder</code> 通过它可以配置Json序列化的参数，除此外还可以 <code>JsonSerialize</code> 配置序列化函数。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 依赖注入 DI</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 如何理解DI</h3>
<div class="outline-text-3" id="text-4-1">
<p>
我的理解是，不要去理解，用就行了。可以参考 <a href="http://zzyongx.github.io/blogs/bluff-Ioc-DI.html">唬人的Ioc和DI</a>
</p>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 从单例到DI</h3>
<div class="outline-text-3" id="text-4-2">
<p>
一般聊到单例都是指这样一种形式 <code>SingletonClass.create</code> 无论这个函数调用多少次，这个函数只返回同一个对象。Spring中所有DI的类都是单例的（默认如此，但是可以改变），单例对象的值是可以使用Spring自动注入的。这个过程可以分两步：
</p>
<ul class="org-ul">
<li>构造单例表
</li>
<li>注入单例对象
</li>
</ul>

<p>
可以这么理解，Spring启动时，根据一定的规则，生成一个全局的 <code>Map&lt;String, Object&gt;</code> 的单例表，通过这个表来实现单例。这个表的初始化，通过以下方式完成：
</p>
<ul class="org-ul">
<li>扫描指定包，如果类带有注解 <code>@Component @RestController</code> 等，添加到单例表中。
</li>
<li>标记为@Bean的函数创建的对象，添加到单例表中。
</li>
</ul>

<p>
单例表完成后，扫描所有标记为 <code>@Autowired</code> 的成员变量和成员函数，根据名字查照单例表，用相应的值初始化。
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Spring DI 包括哪些组成部分</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>Component     定义可以被DI的类
</li>
<li>Bean          创建用来DI的变量
</li>
<li>Autowired     需要DI的变量
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 实例讲解DI</h3>
<div class="outline-text-3" id="text-4-4">
<p>
MemoController.java
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@RestController</span>
<span style="color: #ff00ff;">@RequestMapping</span>(<span style="color: #00ff00;">"/api"</span>)
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">MemoController</span> {
  <span style="color: #ff00ff;">@Autowired</span> <span style="color: #00ff00;">MemoManager</span> <span style="color: #ffff00;">memoManager</span>;

  <span style="color: #ff00ff;">@RequestMapping</span>(value = <span style="color: #00ff00;">"/memo"</span>, method = <span style="color: #ff00ff;">RequestMethod</span>.GET)
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">ApiResult</span> <span style="color: #0000ff; font-weight: bold;">listMemo</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> memoManager.list();
  }
}
</pre>
</div>

<p>
MemoManager.java
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Component</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">MemoManager</span> {
  <span style="color: #ff00ff;">@Autowired</span> <span style="color: #00ff00;">JedisPool</span> <span style="color: #ffff00;">jedisPool</span>;

  <span style="color: #00ffff; font-weight: bold;">final</span> <span style="color: #00ff00;">String</span> <span style="color: #ffff00;">KEY</span> = <span style="color: #00ff00;">"memo"</span>;

  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">ApiResult</span> <span style="color: #0000ff; font-weight: bold;">list</span>() {
    <span style="color: #00ffff; font-weight: bold;">try</span> (<span style="color: #00ff00;">Jedis</span> <span style="color: #ffff00;">c</span> = jedisPool.getResource()) {
      <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">ApiResult</span>&lt;<span style="color: #00ff00;">Map</span>&gt;(c.hgetAll(KEY));
    }
  }
}
</pre>
</div>

<p>
RootConfig.java
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Configuration</span>
<span style="color: #ff00ff;">@ComponentScan</span>({<span style="color: #00ff00;">"example"</span>})
<span style="color: #ff00ff;">@PropertySource</span>(<span style="color: #00ff00;">"classpath:application-${spring.profiles.active}.properties"</span>)
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">RootConfig</span> {
  <span style="color: #ff00ff;">@Autowired</span> <span style="color: #00ff00;">Environment</span> <span style="color: #ffff00;">env</span>;

  <span style="color: #ff00ff;">@Bean</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">JedisPool</span> <span style="color: #0000ff; font-weight: bold;">jedisPool</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">JedisPool</span>(
      env.getRequiredProperty(<span style="color: #00ff00;">"redis.url"</span>),
      env.getRequiredProperty(<span style="color: #00ff00;">"redis.port"</span>, Integer.<span style="color: #00ffff; font-weight: bold;">class</span>));
  }
}
</pre>
</div>
</div>

<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1"><span class="section-number-4">4.4.1</span> MemoController 有注入需求</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
<code>@RestController</code> 默认也是单例的。我们找不到 <code>MemoController</code> 实例化的地方，它的成员变量 <code>memoManager</code> 只能通过注入的方式初始化。根据注入规则，需要名字为 <b>memoManager</b> 的对象。
</p>
</div>
</div>

<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2"><span class="section-number-4">4.4.2</span> MemoManager 提供了注入能力</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
根据规则，spring在启动时，发现 <code>MemoManager</code> 有 <code>@Component</code> 注解，于是名字为 <b>memoManager</b> 的对象被记了下来。当需要名为 <b>memoManager</b> 对象时，就可以使用了。
</p>
</div>
</div>

<div id="outline-container-sec-4-4-3" class="outline-4">
<h4 id="sec-4-4-3"><span class="section-number-4">4.4.3</span> DI 是递归的</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
<code>MemoManager</code> 也有标记为 <code>@Autowired</code> 的成员变量 <code>jedisPool</code> ，也需要注入。因为 JedisPool 是第三方库，我们使用 <code>@Bean</code> 标记函数的方法，提供 <b>jedisPool</b> 对象。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 以上只是猜测</h3>
<div class="outline-text-3" id="text-4-5">
<p>
以上描述的过程都是 <b>不负责任</b> 的猜测，Spring是不是这么做的不清楚，但是这么做是肯定可以实现的。
</p>

<p>
以上的描述都假设单例表是个Map，这不一定是真的，例如 <b>memoManager</b> 需要被注入，它的类型是 <b>MemoManager</b> ，只需要根据类型就能找到相应的依赖对象。
</p>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> 给单例对象命名</h3>
<div class="outline-text-3" id="text-4-6">
<p>
本例中 <b>只有一个</b> JedisPool，隐含了只有一个Redis，假设我们有多个Redis怎么办？这时靠默认名字（小写类名的第一个字母）显然不行了。这时需要给Bean起名字，同时Autowired时指定需要的Bean的名字。
</p>
<ol class="org-ol">
<li>@Bean("redisPoolOne") 给Bean命名
</li>
<li>@Qualifier("redisPoolOne") @Autowired JedisPool jedisPool 指定注入的Bean的名字。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> @Bean注解函数</h3>
<div class="outline-text-3" id="text-4-7">
<p>
上例中，无论 <code>jedisPool()</code> 调用多少次，返回的都是同一个对象。
</p>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> @Autowired 和静态函数、静态成员变量</h3>
<div class="outline-text-3" id="text-4-8">
<p>
<code>@Autowired</code> 不能用于静态函数和静态成员变量
</p>
</div>
</div>

<div id="outline-container-sec-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> Component 的局限性</h3>
<div class="outline-text-3" id="text-4-9">
<p>
标记为 <code>Component</code> 的类可以被自动注入，它的构造函数必须是无参的，借助 <code>Autowired</code> 的自动绑定，其实构造函数也不需要参数。当我们需要从配置文件读取配置，然后通过构造函数传递配置时，无参构造函数就不够用了。
我们可以通过用 <code>Autowired</code> 标记构造函数，传递参数给构造函数，参数规则同 <code>Autowired</code> 标记的变量。如果参数是类似String的简单变量，这种方法也不可行。此时可以通过去掉 <code>Component</code> 注解，通过 <code>Bean</code> 来完成。
就像JedisPool那样。
</p>
</div>
</div>

<div id="outline-container-sec-4-10" class="outline-3">
<h3 id="sec-4-10"><span class="section-number-3">4.10</span> 线程安全</h3>
<div class="outline-text-3" id="text-4-10">
<p>
使用DI时一定要牢记，默认DI是单例的，也就是说用于DI的类一定要是线程安全的。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 扔掉 XML 配置</h2>
<div class="outline-text-2" id="text-5">
<p>
spring有两种配置方式，一种基于XML，一种基于java代码（ <code>java config</code> ），最近的资料，推崇 <code>java config</code> 。我学习spring的时间较晚，只会后者。
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 配置什么？</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>url 和处理函数的映射
</li>
<li>Web框架的配置
</li>
<li>各种Component所在的包
</li>
<li>不同环境的配置文件
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> url和处理函数的映射</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">WebInitializer</span> <span style="color: #00ffff; font-weight: bold;">extends</span> <span style="color: #00ff00;">AbstractAnnotationConfigDispatcherServletInitializer</span> {
  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">protected</span> <span style="color: #00ff00;">Class</span>&lt;?&gt;[] <span style="color: #0000ff; font-weight: bold;">getRootConfigClasses</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">Class</span>&lt;?&gt;[] {
      RootConfig.<span style="color: #00ffff; font-weight: bold;">class</span>, DaoConfig.<span style="color: #00ffff; font-weight: bold;">class</span>
    };
  }

  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">protected</span> <span style="color: #00ff00;">Class</span>&lt;?&gt;[] <span style="color: #0000ff; font-weight: bold;">getServletConfigClasses</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">Class</span>&lt;?&gt;[] { WebConfig.<span style="color: #00ffff; font-weight: bold;">class</span> };
  }

  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">protected</span> <span style="color: #00ff00;">String</span>[] <span style="color: #0000ff; font-weight: bold;">getServletMappings</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">String</span>[] { <span style="color: #00ff00;">"/"</span> };
  }

  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">protected</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">customizeRegistration</span>(<span style="color: #00ff00;">Dynamic</span> <span style="color: #ffff00;">registration</span>) {
    registration.setMultipartConfig(
      <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">MultipartConfigElement</span>(<span style="color: #00ff00;">"/tmp"</span>, 1500_000, 1500_000, 1500_000));
  }
}
</pre>
</div>

<p>
上文以及说了用 <code>RequestMapping</code> 映射url和处理函数，这里又说需要配置，这多少令人困惑。 <code>RequestMapping</code> 只是告诉spring这个映射关系，但是Servlet容器并不知道，它甚至不知道Spring的存在。
</p>

<p>
在Servlet3以前需要通过XML告诉Servlet容器，url和处理函数的映射关系，在Servlet3及以后的版本，只要实现了<a href="http://docs.oracle.com/javaee/7/api/javax/servlet/ServletContainerInitializer.html">ServletContainerInitializer</a> 接口，Servlet容器会自动发现其实现，并做相关配置，当然Spring做了封装，配置起来更简单。
</p>

<p>
首先继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> ， <code>getRootConfigClasses</code> 配置应用上下文，主要是一些全局配置， <code>getServletConfigClasses</code> 配置Servlet上下文， <code>getServletMappings</code> 配置对应的url。
</p>

<p>
如果需要配置多个Servlet上下文，实现多个 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 即可，如果需要更精细的配置，可以研究 <code>AbstractDispatcherServletInitializer</code> 。
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 配置Servlet上下文</h3>
<div class="outline-text-3" id="text-5-3">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Configuration</span>
<span style="color: #ff00ff;">@EnableWebMvc</span>
<span style="color: #ff00ff;">@ComponentScan</span>({<span style="color: #00ff00;">"example.api"</span>})
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">WebConfig</span> <span style="color: #00ffff; font-weight: bold;">extends</span> <span style="color: #00ff00;">WebMvcConfigurerAdapter</span> {
  <span style="color: #ff00ff;">@Override</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">configureMessageConverters</span>(<span style="color: #00ff00;">List</span>&lt;<span style="color: #00ff00;">HttpMessageConverter</span>&lt;?&gt;&gt; <span style="color: #ffff00;">converters</span>) {
    converters.add(<span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">StringHttpMessageConverter</span>());

    <span style="color: #00ff00;">Jackson2ObjectMapperBuilder</span> <span style="color: #ffff00;">builder</span> = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">Jackson2ObjectMapperBuilder</span>();
    builder.featuresToDisable(<span style="color: #ff00ff;">SerializationFeature</span>.WRITE_DATES_AS_TIMESTAMPS);
    builder.featuresToDisable(<span style="color: #ff00ff;">SerializationFeature</span>.FAIL_ON_EMPTY_BEANS);
    builder.serializationInclusion(<span style="color: #ff00ff;">JsonInclude</span>.<span style="color: #ff00ff;">Include</span>.NON_NULL);
    converters.add(<span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">MappingJackson2HttpMessageConverter</span>(builder.build()));
  }
}
</pre>
</div>

<p>
<code>@Configuration</code> 表明这是个配置， <code>@EnableWebMvc</code> 启用Mvc， <code>@ComponentScan</code> 配置 Controller 所在的包。继承 <code>WebMvcConfigurerAdapter</code> 配置Web细节。
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 配置应用上下文</h3>
<div class="outline-text-3" id="text-5-4">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Configuration</span>
<span style="color: #ff00ff;">@ComponentScan</span>({<span style="color: #00ff00;">"example"</span>})
<span style="color: #ff00ff;">@PropertySource</span>(<span style="color: #00ff00;">"classpath:application-${spring.profiles.active}.properties"</span>)
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">RootConfig</span> {
  <span style="color: #ff00ff;">@Autowired</span> <span style="color: #00ff00;">Environment</span> <span style="color: #ffff00;">env</span>;

  <span style="color: #ff00ff;">@Bean</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">JedisPool</span> <span style="color: #0000ff; font-weight: bold;">jedisPool</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">JedisPool</span>(
      env.getRequiredProperty(<span style="color: #00ff00;">"redis.url"</span>),
      env.getRequiredProperty(<span style="color: #00ff00;">"redis.port"</span>, Integer.<span style="color: #00ffff; font-weight: bold;">class</span>));
  }
}
</pre>
</div>

<p>
<code>@ComponentScan</code> 配置 <code>@Component</code> 类所在的包。
</p>
</div>
</div>

<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 配置文件</h3>
<div class="outline-text-3" id="text-5-5">
<p>
虽说没有了XML，可是并不能没有配置，spring支持 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Properties.html">Properties</a> 配置。通过 <code>@PropertySource</code> 指定文件的位置， <code>Environment</code> 会被自动注入，用来获取具体配置项。
</p>

<p>
在具体的开发中，有开发环境，测试环境，线上环境，等等，它们的配置通常是不同的。通过java <code>spring.profiles.active</code> 环境变量可以辅助指定使用的配置文件。参见RootConfig。
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> @Profile</h3>
<div class="outline-text-3" id="text-5-6">
<p>
当 <code>spring.profiles.active</code> 的值等于 <code>Profile</code> 的值时，才激活响应的类或者创建Bean的方法。
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> 创建一个Bean来做相应的配置</h3>
<div class="outline-text-3" id="text-5-7">
<p>
在 <a href="#sec-3-2-6">3.2.6</a> 中，我们通过创建Bean来配置支持 MatrixVariable。我猜是spring在初始化时，寻找相应的Bean来做初始化，如果没有就使用默认值。
</p>
</div>
</div>

<div id="outline-container-sec-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> 集成一个类来做相应的配置</h3>
<div class="outline-text-3" id="text-5-8">
<p>
在 <a href="#sec-3-3-5">3.3.5</a> 中，通过继承类，来实现JSONP的启用。我猜是spring在初始化是，需要相应的类的最底层的子类来生成相应的配置。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 异常处理</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 无处不在的异常</h3>
<div class="outline-text-3" id="text-6-1">
<p>
jdk和许多的java库，都会抛出异常。在WEB应用中，要和数据库，Redis，HTTP接口等众多其它服务打交道，能抛出异常的地方太多了，要时时检查异常，会淹没代码的业务逻辑。
</p>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 无能为力的异常</h3>
<div class="outline-text-3" id="text-6-2">
<p>
在WEB环境下（其它环境也差不多），当异常发生时，所能做的只是返回错误，所以检查异常并没有特别的意义。
</p>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Spring的异常观</h3>
<div class="outline-text-3" id="text-6-3">
<p>
在Spring封装异常的地方（例如DAO，RestClientException），它把所有 <b>Checked</b> 异常变成了 <b>Unchecked</b> 异常，在代码和函数签名里，不用特意的检查异常。
</p>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 统一的异常处理</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Spring提供了统一的异常处理机制，借助 <code>@ControllerAdvice</code> 和 <code>@ExceptionHandler</code> ，在统一的地方配置好异常处理函数就可以了。业务逻辑可以完全不关心异常。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@ControllerAdvice</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">GlobalExceptionHandler</span> {
  <span style="color: #ff00ff;">@ExceptionHandler</span>(DataAccessException.<span style="color: #00ffff; font-weight: bold;">class</span>)
  <span style="color: #ff00ff;">@ResponseBody</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">ApiResult</span> <span style="color: #0000ff; font-weight: bold;">dataAccessExcption</span>(<span style="color: #00ff00;">Exception</span> <span style="color: #ffff00;">e</span>) {
    e.printStackTrace();
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">ApiResult</span>(<span style="color: #ff00ff;">Errno</span>.INTERNAL_ERROR, <span style="color: #00ff00;">"interal db error"</span>);
  }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> RestTemplate</h2>
<div class="outline-text-2" id="text-7">
<p>
RestTemplate 主要解决两个问题：
</p>
<ol class="org-ol">
<li>Http请求都大同小异，建立连接， <b>准备请求参数</b> ，发送请求，接受请求， <b>解析返回内容</b> ，关闭连接。
</li>
<li>准备请求参数和解析返回内容的过程自动化。
</li>
</ol>

<p>
假设请求返回Json <code>{"version": "1.2.3", "license": "Apache"}</code> ，对应的对象是Version。使用 <code>Version version = new RestTemplate(version-api, Version.class)</code> 。
</p>

<p>
更多详细内容参考：RestClient.java
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 数据库相关</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 名目繁多的ORM</h3>
<div class="outline-text-3" id="text-8-1">
<p>
ORM 要解决的问题是，java对象和数据表如何映射。有 <code>Hibernate JDO JPA</code> 等多种方案，这些不熟，不予置评。但理想的ORM应该是什么样的？
</p>
<ul class="org-ul">
<li>对象和数据表的映射应该简单
</li>
<li>映射背后的SQL应该透明
</li>
</ul>
<p>
我推荐 <a href="http://zzyongx.github.io/blogs/mybatis-spring-howto.html">mybatis</a>。
</p>
</div>
</div>

<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> 配置DataSource</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<a href="https://docs.oracle.com/javase/8/docs/api/javax/sql/DataSource.html">DataSource</a> 是一个java接口，基于它实现数据库连接池的功能。有很多实现，例如：<a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> <a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">druid</a>
</p>
</div>
</div>

<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3"><span class="section-number-3">8.3</span> JdbcTemplate</h3>
<div class="outline-text-3" id="text-8-3">
<p>
INSERT，UPDATE，DELETE，使用JdbcTemplate很方便（INSERT需要返回自增ID除外），SELECT略麻烦。测试时可以使用。
具体参考 <a href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/htmlsingle/#jdbc-JdbcTemplate">JdbcTemplate</a>
</p>
</div>
</div>

<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4"><span class="section-number-3">8.4</span> 事务</h3>
<div class="outline-text-3" id="text-8-4">
<p>
事务通常都是借助Spring的机制来控制的，为了在spring中使用事务，需要创建事务管理器。这里对函数的名字有要求，因为函数名也是 <code>Bean</code> 的名字。
</p>
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Configuration</span>
<span style="color: #ff00ff;">@EnableTransactionManagement</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ffff; font-weight: bold;">class</span> <span style="color: #00ff00;">DaoConfig</span> {
  <span style="color: #ff00ff;">@Bean</span>
  <span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">DataSourceTransactionManager</span> <span style="color: #0000ff; font-weight: bold;">transactionManager</span>() {
    <span style="color: #00ffff; font-weight: bold;">return</span> <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">DataSourceTransactionManager</span>(dataSource());
  }
}
</pre>
</div>

<p>
有两种使用事务的方式
</p>
</div>
<div id="outline-container-sec-8-4-1" class="outline-4">
<h4 id="sec-8-4-1"><span class="section-number-4">8.4.1</span> Transactional</h4>
<div class="outline-text-4" id="text-8-4-1">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ff00ff;">@Transactional</span>
<span style="color: #00ffff; font-weight: bold;">public</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">databaseOperation</span>() {
  <span style="color: #ffff00;">// </span><span style="color: #ffff00;">database operation</span>
}
</pre>
</div>

<p>
通过 <code>@Transactional</code> 注解一个 <b>public</b> 函数，该函数内部的数据操作是一个事务。
</p>
</div>
</div>

<div id="outline-container-sec-8-4-2" class="outline-4">
<h4 id="sec-8-4-2"><span class="section-number-4">8.4.2</span> TransactionTemplate</h4>
<div class="outline-text-4" id="text-8-4-2">
<div class="org-src-container">

<pre class="src src-java"><span style="color: #ffff00;">// </span><span style="color: #ffff00;">init</span>
<span style="color: #00ffff; font-weight: bold;">this</span>.transactionTemplate = <span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">TransactionTemplate</span>(transactionManager);

<span style="color: #ffff00;">// </span><span style="color: #ffff00;">use</span>
transactionTemplate.execute(<span style="color: #00ffff; font-weight: bold;">new</span> <span style="color: #00ff00;">TransactionCallbackWithoutResult</span>() {
    <span style="color: #00ffff; font-weight: bold;">protected</span> <span style="color: #00ff00;">void</span> <span style="color: #0000ff; font-weight: bold;">doInTransactionWithoutResult</span>(<span style="color: #00ff00;">TransactionStatus</span> <span style="color: #ffff00;">status</span>) {
      <span style="color: #ffff00;">// </span><span style="color: #ffff00;">database operation</span>
    }
  });
</pre>
</div>

<p>
通过 <code>TransactionTemplate</code> 封装了一段需要保持事务的操作。
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 性能监控和slf4j</h2>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> API 文档</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: root</p>
<p class="date">Created: 2016-04-18 一 17:11</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.4.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
