#+TITLE: 破解linux负载高
#+OPTIONS: toc:nil
#+SETUPFILE: ../setup/theme-readtheorg-local.setup
#+KEYWORDS: linux load high

Linux的load到底是个啥，[[http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html][Linux Load Averages]] 已经说的很清楚了，它是系统负载，不是CPU负载。文末还引用了loadavg.c注释中颇具嘲讽话，  ~load其实没啥用，但很多人相信它有用，没办法我们只好费劲维护它啦~ 。那到底有没有用？

* 系统负载 vs CPU负载
如果load是cpu负载，那很简单，load高的时候只要看top，就能找到哪个进程在搞事。如果load是系统负载，很多人会迷茫，系统是个啥，我该如何找到那个搞事儿的进程。load高说明出问题了，但是不知道出了什么问题，尤其是CPU占用还不高的时候。

* 系统负载包含哪些负载
简单说，处于 =R= 和 =D= 状态的进程，都给负载做了贡献。
=R= 是指可运行的进程，包含正在运行和等待运行的，反映了cpu的需求程度，如果 =R= 进程的数量超过了cpu的个数，cpu占用率肯定比较高。
=D= 是处于不可中断的等待，通常发生在等待磁盘IO（磁盘IO大部分过程是可中断的，但有少部分不可中断）。但是在内核中有很多操作，都会把进程标记为 =D= 。
=D= 状态非常霸气，因为这种状态的进程是kill不掉的，但正常情况进程处在 =D= 状态的时间非常短。如果长时间处在 =D= 状态，很可能是文件系统或者硬件出问题了。虽然处于 =D= 状态的时间短，但架不住多，如果有上千的进程频繁 =D= 也可能导致负载高。

* load有没有用
个人以为有用。首先load高（例如cpu核数的2倍）系统肯定出有问题了，虽然没法判断啥问题，但作为监控指标很明了。其次load高分两种情况，常见的一种是请求量变大了，这时候load作为扩容指标很合适，另外一种是系统异常（业务系统出bug了或硬件坏了），这时候扩容没用。

load指标简单是优势，也是劣势，那就是配置成多少合适，不同系统对load高的容忍度不同。虽然不是cpu负载，但是监控配置成cpu的倍数通常是个不错的注意。

* 如何排查load高
简单的方法是先看top，然后看进程（线程）数量，哪类进程数量异常，最后查看 =D= 和 =S= 的进程。我碰到过一例cpu不高，但是有上千个进程在运行，其中处于 =D= 状态的进程数量和load基本一致。
比较高级点的方法在 [[http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html][Linux Load Averages]] 的文末有说明，主要和内核调度有关。
