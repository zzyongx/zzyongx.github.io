#+TITLE: linux命令备忘
#+SETUPFILE: ../setup/theme-readtheorg-local.setup
#+OPTIONS: toc:nil

* java 工具

** 将汉字编码为utf8
#+BEGIN_SRC bash
# echo -n "善良" | native2ascii
\u5584\u826f
#+END_SRC

java的properties文件不能有汉字，可以用~native2ascii~转成utf8写在文件中

** 替换war包中的文件
~jar uf app.war WEB-INF/classes/application-online.properties~ 替换文件，注意必须和war包中的文件保持相同路径

* 字符串

** 获取随机字符串
#+BEGIN_SRC bash
# head -n 1024 /dev/urandom | md5sum
9b480cfa33d33009cbae5c0f10d7b2f7  -
#+END_SRC

碰到需要随机数的场合，这是一个不错的方法

** 二进制数据和16进制转换
1. 16进制转二进制 =echo "6F0AD0BFEE7D4B478AFED096E03CD80A" | xxd -r -p | base64=
2. 二进制转16进制 ~echo "bwrQv+59S0eK/tCW4DzYCg==" | base64 -d | xxd -l 16 -c 256 -p~  注意 =-l= 指定的是二进制的长度，必须指定对 =-c= 指定换行位置，用于数据较长时

* OpenSSL

** HMAC
#+BEGIN_SRC bash
# echo -n "initial text" | openssl dgst -sha1 -hmac "9b480cfa33d33009cbae5c0f10d7b2f7"
(stdin)= 32740bc521b8476818d7b7ba056ff7e758217adc
#+END_SRC

可以用来检查编程结果的正确性

** 对称加密
1. =openssl rand 32 -out keyfile= 产生秘钥，keyfile是二进制的
2. =openssl rand 32 -base64 -out keyfile.b64= keyfile.b64是base64的，除了正常的base64，文件末尾多了一个换行
3. =openssl rand 32 -hex -out keyfile.hex= keyfile.hex是十六进制的
4. =openssl enc -aes-256-ecb -in content -nosalt -a -A -K $(cat keyfile.hex) -out content.dec= 加密
5. =openssl enc -aes-256-ecb -in content.dec -nosalt -a -A -p -K $(cat keyfile.hex) -d= 解密
6. =openssl enc -aes-256-ecb -in content -nosalt -a -A -p -kfile keyfile= 加密，结果和4不同，kfile参数指定的key并不是加密使用的key
7. 4,5 使用 =-K= 指定了实际使用的key，用于不同语言间程序互操作，如果加解密都使用openssl，6也可以

** 非对称加密
1. =openssl genrsa -out private.pem 1024= private.pem 是产生的私钥
2. =openssl rsa -in private.pem -inform PEM -outform PEM -pubout -out public.pem= 根据私钥生成公钥
3. =openssl rsautl -encrypt -pubin -inkey public.pem -in keyfile -out keyfile.enc= 用公钥加密对称秘钥
4. =openssl rsautl -decrypt -inkey private.pem -in keyfile.enc -out keyfile.dec= 用私钥解密对称秘钥

* Bash
** ssh 自动补全主机名
#+BEGIN_SRC bash
# cat > /etc/bash_completion.d/ssh
complete -W "$(echo `cat ~/.ssh/known_hosts | cut -f 1 -d ' ' | sed -e s/,.*//g | uniq | grep -v "\["`;)" ssh
# source /etc/bash_completion.d/ssh
# cat >> ~/.bashrc
for f in /etc/bash_completion.d/*; do
  source $f
done
#+END_SRC

** 如何用命令删除文件的第一行
#+BEGIN_SRC bash
# tail -n +2 file
#+END_SRC

** date 命令
- ~date +%s~ 获取时间戳
- ~date @1480065287~ 获取时间戳对应的时间

* Net
** 测试网速
- ~curl http://example.com/bigfile.txt >/dev/null -vv~ 会显示打开速度
- ~rsync -v example.com::path/bigfile.txt /bigfile.txt.`date +%s`~ 使用rsync，目标文件必须每次都不同
